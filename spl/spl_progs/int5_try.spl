alias physicalSP S0;
physicalSP = ([PTBR + 2 * (SP/512)] * 512) + (SP % 512);

alias sysCallNo S1;
sysCallNo = [physicalSP - 1];

//....................Implementation of Fork.............................

if (sysCallNo == 8) then

  //Finding free PCB slot
  alias PCB S2;
  PCB = 0;
  while ([READY_LIST + (32 * PCB) + 1] != 0) do
    if (PCB >= 31) then
      print("No free PCB");
      [physicalSP - 2] = -1;
      ireturn;
    endif;
    PCB = PCB + 1;
  endwhile;

  //Setting up the childPID
  alias childPID S3;
  childPID = PCB;
  [READY_LIST + (32 * childPID) + 0] = childPID;

  //Duplicating the process
  alias parentPID S4;
  parentPID = (PTBR - 1024)/8; //finding the parent PID
  alias parentPageTable S5;
  parentPageTable = PAGE_TABLE + (parentPID * 8);

  //Counting number of valid pages
  alias counter S2; //Reusing S2, no use now
  counter = 0;
  alias validPages S6;
  validPages = 0;
  while (counter < 4) do
    if ([PTBR + (2 * counter) + 1] == "01" || [PTBR + (2 * counter) + 1] == "11") then
      validPages = validPages + 1;
    endif;
    counter = counter + 1;
  endwhile;

  //Counting number of free memory list
  counter = 25;
  alias freePages S7;
  freePages = 0;
  while (counter < 64) do
    if ([MEM_LIST + counter] == 0) then
      freePages = freePages + 1;
    endif;
    counter = counter + 1;
  endwhile;

  if (freePages < validPages) then
    print("Not enough memory");
    [physicalSP - 2] = -1;
    ireturn;
  endif;

  //Allocating pages to child process
  alias PTBR_childProcess S8;
  PTBR_childProcess = PAGE_TABLE + (childPID * 8);

  counter = 21;
  freePages = 0; //simply reusing the variable, no reference to freePages in memory
  while (freePages < validPages) do
    if ([MEM_LIST + counter] == 0) then
      [MEM_LIST + counter] = 1;

      //Copying content word-by-word

      alias i S9;
      i = 0;
      while (i < 512) do
        [(counter * 512) + i] = [[PTBR + (2 * freePages)] * 512 + i];
        i = i + 1;
      endwhile;

      [PTBR_childProcess + (2 * freePages) + 0] = counter;
      [PTBR_childProcess + (2 * freePages) + 1] = [PTBR + (2 * freePages) + 1];
      freePages = freePages + 1;
    endif;
    counter = counter + 1;
  endwhile;

  breakpoint;
  //Step 4 should be complete by now. Check if everything is done.

  //Setting up the PTBR, IP and SP
  [READY_LIST + (32 * childPID) + 5] = PTBR_childProcess;
  [READY_LIST + (32 * childPID) + 4] = [physicalSP];
  [READY_LIST + (32 * childPID) + 3] = SP - 1;

  //Copying the registers

  [READY_LIST + (32 * childPID) + 2] = BP;
  [READY_LIST + (32 * childPID) + 6] = PTLR;
  [READY_LIST + (32 * childPID) + 7] = R0;
  [READY_LIST + (32 * childPID) + 8] = R1;
  [READY_LIST + (32 * childPID) + 9] = R2;
  [READY_LIST + (32 * childPID) + 10] = R3;
  [READY_LIST + (32 * childPID) + 11] = R4;
  [READY_LIST + (32 * childPID) + 12] = R5;
  [READY_LIST + (32 * childPID) + 13] = R6;
  [READY_LIST + (32 * childPID) + 14] = R7;

  //Copying the per-process File Table

  counter = 15;
  while (counter < 31) do
    [READY_LIST + (32 * childPID) + counter] = [READY_LIST + (32 * parentPID) + counter];
    [READY_LIST + (32 * childPID) + counter + 1] = [READY_LIST + (32 * parentPID) + counter + 1];
    alias PCB S12;
    PCB = [READY_LIST + (32 * childPID) + counter];
    if (PCB != -1) then
		  [PCB*2 + 1] = [PCB*2 + 1] + 1;//incrementing count in system-wide open file table
	  endif;
    counter = counter + 2;
  endwhile;

  //Setting state of child process as ready

  [READY_LIST + (32 * childPID) + 1] = 1;

  //Setting up ParentPID

  [READY_LIST + (32 * childPID) + 31] = parentPID;

  [physicalSP - 2] = childPID;
  alias childSP S10;
  childSP = ([PTBR_childProcess + 2 * ((SP - 1) / 512)] * 512) + ((SP - 1) % 512);
  [childSP - 1] = -2;

endif;

ireturn;
